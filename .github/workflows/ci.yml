name: CarIActerology CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  PYTHON_VERSION: '3.11'
  
jobs:
  lint-and-test:
    name: Code Quality & Testing
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true
        installer-parallel: true
        
    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}
        
    - name: Install dependencies
      if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
      run: poetry install --no-interaction --no-root
      
    - name: Install project
      run: poetry install --no-interaction
      
    - name: Run Ruff linting
      run: |
        poetry run ruff check .
        
    - name: Run Black code formatting check
      run: |
        poetry run black --check .
        
    - name: Run mypy type checking
      run: |
        poetry run mypy . --ignore-missing-imports
        
    - name: Run tests with pytest
      run: |
        poetry run pytest --cov=. --cov-report=xml --cov-report=html
        
    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v3
      if: success()
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        
    - name: Test Streamlit app can start
      run: |
        poetry run python -c "import streamlit as st; print('Streamlit import successful')"
        poetry run python -c "import sys; sys.path.append('.'); from data.mock_data import get_primary_character_type; print('Mock data functional')"

  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: lint-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Bandit Security Linter
      uses: securecodewarrior/github-action-bandit@v1
      with:
        config-file: .bandit
        
    - name: Run Safety check for vulnerabilities
      run: |
        pip install safety
        safety check --json --output safety-report.json || true
        
    - name: Upload security reports
      uses: actions/upload-artifact@v3
      with:
        name: security-reports
        path: |
          safety-report.json
          bandit-report.json

  build-and-validate:
    name: Build Validation
    runs-on: ubuntu-latest
    needs: [lint-and-test, security-scan]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Poetry
      uses: snok/install-poetry@v1
      
    - name: Install dependencies
      run: poetry install --no-interaction
      
    - name: Validate all pages can import
      run: |
        poetry run python -c "
        import sys
        import os
        sys.path.append('.')
        
        pages = ['app.py', 'pages/1_Chat.py', 'pages/2_Analysis.py', 'pages/3_Dashboard.py', 'pages/4_Reports.py', 'pages/5_Settings.py', 'pages/6_Help.py']
        
        for page in pages:
          try:
            spec = __import__('importlib.util').util.spec_from_file_location('test_module', page)
            if spec:
              print(f'âœ“ {page}: Import validation successful')
            else:
              print(f'âœ— {page}: Import validation failed')
              exit(1)
          except Exception as e:
            print(f'âœ— {page}: {e}')
            exit(1)
        print('All pages validated successfully!')
        "
        
    - name: Test mock data integrity
      run: |
        poetry run python -c "
        import sys
        sys.path.append('.')
        from data.mock_data import get_primary_character_type, get_mock_user_profile, get_character_evolution_data, CHARACTER_TYPES
        
        # Test data integrity
        char_type = get_primary_character_type()
        user_profile = get_mock_user_profile()
        evolution_data = get_character_evolution_data(6)
        
        assert len(CHARACTER_TYPES) == 8, f'Expected 8 character types, got {len(CHARACTER_TYPES)}'
        assert char_type['name'], 'Character type name missing'
        assert 0 <= user_profile['confidence_score'] <= 1, 'Invalid confidence score'
        assert len(evolution_data) == 6, 'Evolution data length incorrect'
        
        print('âœ“ Mock data integrity validated')
        "
        
    - name: Test report generation
      run: |
        poetry run python -c "
        import sys
        sys.path.append('.')
        from modules.report_generator import get_available_report_types
        
        report_types = get_available_report_types()
        assert len(report_types) >= 3, f'Expected at least 3 report types, got {len(report_types)}'
        
        for report_id, report_info in report_types.items():
          assert 'name' in report_info, f'Report {report_id} missing name'
          assert 'description' in report_info, f'Report {report_id} missing description'
          
        print('âœ“ Report generation system validated')
        "

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-validate
    if: github.ref == 'refs/heads/develop'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Deploy to Streamlit Cloud Staging
      run: |
        echo "ðŸš€ Deploying to staging environment..."
        echo "Staging URL will be available at: https://cariacterology-staging.streamlit.app"
        # Note: Actual Streamlit Cloud deployment happens via their GitHub integration
        # This step would trigger the deployment webhook or API call
        
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-validate
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Deploy to Streamlit Cloud Production
      run: |
        echo "ðŸš€ Deploying to production environment..."
        echo "Production URL will be available at: https://cariacterology.streamlit.app"
        # Note: Actual Streamlit Cloud deployment happens via their GitHub integration
        
    - name: Create deployment notification
      run: |
        echo "âœ… CarIActerology deployed to production successfully!"
        echo "ðŸ“Š View application: https://cariacterology.streamlit.app"
        echo "ðŸ“ˆ Monitor deployment: Streamlit Cloud Dashboard"
        
  notify:
    name: Deployment Notifications
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: Deployment Success Notification
      run: |
        if [ "${{ github.ref }}" == "refs/heads/main" ]; then
          echo "ðŸŽ‰ Production deployment completed successfully!"
          echo "ðŸ”— Application URL: https://cariacterology.streamlit.app"
        elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
          echo "ðŸš€ Staging deployment completed successfully!"  
          echo "ðŸ”— Staging URL: https://cariacterology-staging.streamlit.app"
        fi